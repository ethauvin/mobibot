import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import io.gitlab.arturbosch.detekt.Detekt
import io.gitlab.arturbosch.detekt.DetektCreateBaselineTask

plugins {
    id 'application'
    id 'com.github.ben-manes.versions' version '0.49.0'
    id 'idea'
    id 'io.gitlab.arturbosch.detekt' version '1.23.1'
    id 'java'
    id 'net.thauvin.erik.gradle.semver' version '1.0.4'
    id 'org.jetbrains.kotlin.jvm' version '1.9.10'
    id 'org.jetbrains.kotlin.kapt' version '1.9.10'
    id 'org.jetbrains.kotlinx.kover' version '0.7.4'
    id 'org.sonarqube' version '4.4.1.3373'
    id 'pmd'
}

defaultTasks 'deploy'

final def packageName = 'net.thauvin.erik.mobibot'
final def deployDir = 'deploy'
final def semverProcessor = "net.thauvin.erik:semver:1.2.1"

final def isCI = (System.getenv('CI') != null)

def isNonStable = { String version ->
    def stableKeyword = ['RELEASE', 'FINAL', 'GA', 'JRE'].any { it -> version.toUpperCase().contains(it) }
    def regex = /^[0-9,.v-]+(-r)?$/
    return !stableKeyword && !(version ==~ regex)
}

mainClassName = packageName + '.Mobibot'

ext.versions = [
        log4j: '2.20.0',
        pmd  : '6.55.0',
]

repositories {
    mavenLocal()
    mavenCentral()
    maven { url 'https://jitpack.io' }
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
}

dependencies {
    kapt(semverProcessor)
    compileOnly(semverProcessor)

    // PircBotX
    implementation 'com.github.pircbotx:pircbotx:2.3.1'
    // implementation fileTree(dir: 'lib', include: '*.jar')

    // Commons (mostly for PircBotX)
    implementation 'org.apache.commons:commons-lang3:3.13.0'
    implementation 'org.apache.commons:commons-text:1.10.0'
    implementation 'commons-codec:commons-codec:1.16.0'
    implementation 'commons-net:commons-net:3.10.0'

    // Google
    implementation 'com.google.code.gson:gson:2.10.1'
    implementation 'com.google.guava:guava:32.1.3-jre'

    // Kotlin
    implementation platform('org.jetbrains.kotlin:kotlin-bom')
    implementation 'org.jetbrains.kotlin:kotlin-stdlib'
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3'
    implementation 'org.jetbrains.kotlinx:kotlinx-cli:0.3.6'

    // Logging
    implementation 'org.slf4j:slf4j-api:2.0.9'
    implementation "org.apache.logging.log4j:log4j-api:$versions.log4j"
    implementation "org.apache.logging.log4j:log4j-core:$versions.log4j"
    implementation "org.apache.logging.log4j:log4j-slf4j2-impl:$versions.log4j"

    implementation 'com.rometools:rome:2.1.0'
    implementation 'com.squareup.okhttp3:okhttp:4.11.0'
    implementation 'com.squareup.okio:okio:3.6.0'
    implementation 'net.aksingh:owm-japis:2.5.3.0'
    implementation 'net.objecthunter:exp4j:0.4.8'
    implementation 'org.json:json:20230618'
    implementation 'org.jsoup:jsoup:1.16.1'

    // Thauvin
    implementation 'net.thauvin.erik:cryptoprice:1.0.1'
    implementation 'net.thauvin.erik:jokeapi:0.9.0'
    implementation 'net.thauvin.erik:pinboard-poster:1.1.0'
    implementation 'net.thauvin.erik.urlencoder:urlencoder-lib:1.4.0'

    testImplementation 'com.willowtreeapps.assertk:assertk-jvm:0.27.0'
//    testImplementation 'org.mockito.kotlin:mockito-kotlin:4.0.0'
//    testImplementation "org.mockito:mockito-core:4.0.0"
    testImplementation 'org.testng:testng:7.8.0'
}

test {
    useTestNG() {
        // excludeGroups.add('twitter')
        if (isCI) {
            excludeGroups.add('no-ci')
        }
        if (!excludeGroups.isEmpty()) {
            println "Excluded test groups: ${excludeGroups}"
        }
    }
}

tasks.withType(Test).configureEach {
    testLogging {
        exceptionFormat = 'full'
        events('skipped', 'failed')
    }
}

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

kapt {
    includeCompileClasspath = false
    arguments {
        arg('semver.project.dir', projectDir)
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}


compileJava {
    dependsOn 'incrementBuildMeta'
    options.compilerArgs += ['-Xlint:unchecked', '-Xlint:deprecation']
}

tasks.named("dependencyUpdates").configure {
    rejectVersionIf {
        isNonStable(it.candidate.version)
    }
}

pmd {
    toolVersion = versions.pmd
    ignoreFailures = true
    ruleSets = []
    ruleSetFiles = files("${projectDir}/config/pmd.xml")
    consoleOutput = true
}

detekt {
    //toolVersion = "main-SNAPSHOT"
    baseline = file("${projectDir}/config/detekt/baseline.xml")
}

tasks.withType(Detekt).configureEach {
    jvmTarget = java.targetCompatibility.toString()
}

tasks.withType(DetektCreateBaselineTask).configureEach {
    jvmTarget = java.targetCompatibility.toString()
}

jar {
    manifest.attributes('Main-Class': mainClassName,
            'Class-Path': '. ./lib/' + configurations.runtimeClasspath.collect { it.getName() }.join(' ./lib/'))
    archiveVersion.set("")
    exclude('log4j2.xml')
}

clean {
    doFirst {
        project.delete(fileTree(deployDir))
    }
}

run {
    args('-h')
}

incrementBuildMeta {
    doFirst {
        if (isCI) {
            println 'No increment with CI.'
        } else {
            buildMeta = DateTimeFormatter.ofPattern("yyyyMMddHHmmss").format(LocalDateTime.now())
        }
    }
}

koverReport {
    defaults {
        xml {
            onCheck = true
        }
        html {
            onCheck = true
        }
    }
}

sonarqube {
    properties {
        property('sonar.organization', 'ethauvin-github')
        property('sonar.projectKey', 'ethauvin_mobibot')
        property('sonar.host.url', 'https://sonarcloud.io')
        property('sonar.coverage.jacoco.xmlReportPaths', "${layout.buildDirectory.get()}/reports/kover/report.xml")
    }
}

tasks.register('copyToDeploy', Copy) {
    from('properties', jar)
    into deployDir
}

tasks.register('copyToDeployLib', Copy) {
    from(configurations.runtimeClasspath) {
        exclude 'annotations-*.jar'
    }
    into(deployDir + '/lib')
}

tasks.register('deploy') {
    description = "Copies all needed files to the ${deployDir} directory."
    group = 'Publishing'
    dependsOn(assemble, jar)
    outputs.dir deployDir
    inputs.files(copyToDeploy, copyToDeployLib)
    doLast {
        file(deployDir + '/logs').mkdir()
    }
    mustRunAfter(clean)
}

tasks.register('release') {
    group = 'Publishing'
    description = 'Releases new version.'
    dependsOn(clean, check, deploy)
    mustRunAfter clean
}
